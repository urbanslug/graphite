#lang racket


(require racket/serialize)
(require file/sha1)
(require "./utils.rkt")
(require "../structures/graph.rkt")

(provide create-node
         update-node
         get-long-id
         gen-directed-graph
         display-graph
         get-node
         add-edge
         add-node
         add-adjacent-node
         remove-adjacent-node
         )

;; sh256 hash as a hex hash
(define (string->hash s)
  (bytes->hex-string (sha256-bytes (string->bytes/utf-8 s))))

;; We don't want to create nodes directly because
;; there are features we want in our nodes such as IDs
;; that we want generated by create node
(define (create-node segment #:id [id #f] #:offset [offset #f] #:edges [adj (set)])
  (let* ([s (if offset
                (string-append segment "+" (number->string offset))
                segment)]
         [id* (if id id (string->hash s)) ])
    (node segment id* offset adj)))

;; name is misleading doesn't mutate the node
;; not allowed to change node id
;; if you want to do that remove the node and generate a new one?
;; What about all adjacent nodes? how do we update those?
;; how can we make this faster?
;; TODO: remove this fn or make sure it doesn't cause IDs to break
(define (update-node n #:sequence [seq #f] #:offset [offset #f] #:edges [edges #f])
  (let ([s (or seq (node-segment n))]
        [i (node-id n)]
        [o (or offset  (node-offset n))]
        [e (or edges (node-edges n))])
    (create-node s #:id i #:offset o #:edges e)))

(define (get-long-id n)
  (node-id n))

;; Do we need this?
(define (add-node graph node)
  (hash-set graph (node-id node) node))

;; TODO: do this without having to recreate the node
;; an edge is a hash
;; rename to add-edge-to-node?
;; O(1)
(define (add-edge n edge)
  (update-node n #:edges (set-add (node-edges n) edge)))

(define (remove-edge n edge)
  (update-node n #:edges (set-remove (node-edges n) edge)))

;; return the node or false
;; takes an id or a node
;; why is this taking node?
(define (get-node g #:node [n #f] #:id [id #f])
  (if n
      (hash-ref g (node-id n) (lambda () n))
      (hash-ref g id (lambda () #f))))

;; O(1)
(define (add-adjacent-node graph node1 node2)
  (let* ([node2-id (node-id node2)]
         [node1-id (node-id node1)]
         ;; TODO: use better names
         ;; update node1
         ;; [g* (hash-set graph node1-id (add-edge  node2-id))]
         [g* (hash-set graph
                       node1-id
                       (add-edge (get-node graph #:node node1)
                                 node2-id))]
         ;; add node2 to the graph
         [g** (hash-set g* (node-id node2) node2)])
    g**))

;; what about removing the edge from the graph?
(define (remove-adjacent-node graph node1 node2)
  (let* ([node2-id (node-id node2)]
         [node1-id (node-id node1)]
         ;; update node1
         [g* (hash-set graph
                       node1-id
                       (remove-edge (get-node graph #:node node1)
                                    node2-id))]
        ;;remove node2 from the graph if it's still there
        [g** (hash-remove g* node2-id)])
    g**))

;; TODO: should we make this ASCII rep a graph?
(define (display-graph g)
  (void (map displayln (hash-values g))))

;; A list of node pairs and a graph and adds the nodes to the graph
(define (gen-directed-graph g l)
  (foldr
   (lambda (node-pair g*)
     (let* ([f (car node-pair)]
            [s (cdr node-pair)]
            [f* (if (hash-has-key? g* (node-id f))
                    (hash-ref g* (node-id f))
                    f)]
            [s* (if (hash-has-key? g* (node-id s))
                    (hash-ref g* (node-id s))
                    s)])
       (add-adjacent-node g* f* s*)))
   g
   l))

